package cmdr

object BashCompletion {

  def completion(
      name: String,
      params: Iterable[ArgParser.ParamInfo],
      commands: Iterable[ArgParser.CommandInfo]
  ): String = {
    val isRoot = name.split(" ").length == 1 // is this the root command?
    val named = params.filter(_.isNamed)
    val namedNonFlags = params.filter(p => p.isNamed && !p.isFlag)
    val positionals = params.filter(!_.isNamed)
    val repeated = positionals.zipWithIndex.find(_._1.repeats)

    val b = new StringBuilder

    // format: off
    b ++= "# This completion function was generated by cmdr (https://github.com/jodersky/cmdr)\n"
    b ++= s"_${name.replace(" ", "_")}() {\n"
    if (isRoot) {
      b ++= "  local cur\n"
      b ++= "  local prev\n"
      b ++= "  local cword\n"
      b ++= "  cword=1\n"
    }
    b ++= s"  local pos\n"
    b ++= s"  pos=0\n"

    b ++= s"  local escaping\n"
    b ++= s"  escaping=0\n"

    // first, iterate over CWORDS to determine the positional index
    b ++= "  for((;cword<COMP_CWORD;cword++)); do\n"
    b ++= "    prev=\"${COMP_WORDS[cword-1]}\"\n"
    b ++= "    cur=\"${COMP_WORDS[cword]}\"\n"

    b ++= "    if [[ $escaping == 1 ]]; then\n"
    b ++= "        ((pos++))\n"
    b ++= "        continue\n"
    b ++= "    fi\n"

    b ++= "    if [[ $cur == -- ]]; then\n"
    b ++= "        escaping=1\n"
    b ++= "        continue\n"
    b ++= "    fi\n"

    // named params don't increment the position
    b ++= "    case \"$cur\" in\n"
    b ++= "        -) ;; \n" // '-' alone is often used as a value
    b ++= "        -*) continue ;;\n"
    b ++= "    esac\n"

    // arguments to named non-flags do not increment the position
    if (!namedNonFlags.isEmpty) {
      b ++= "    case \"$prev\" in\n"
      b ++= "      "; b ++= namedNonFlags.flatMap(_.names).mkString("|"); b ++= ") continue ;;\n"
      b ++= "    esac\n"
    }

    if (!commands.isEmpty) {
      // TODO: this relies on names, use command position instead
      b ++= "    case \"$cur\" in\n"
      for (command <- commands) {
        b ++= s"      ${command.name})\n"
        b ++= "        ((cword++))\n"
        b ++= s"        _${name.replace(" ", "_")}_${command.name}\n"
        b ++= "        return 0 ;;\n"
      }
      b ++= "    esac\n"
    }

    if (!repeated.isEmpty) {
      b ++= "    if [[ $pos == "; b ++= repeated.get._2.toString; b ++= " ]]; then\n"
      b ++= "      break\n"
      b ++= "    fi\n"
    }
    b ++= "    ((pos++))\n"
    b ++= "  done\n"

    // then, suggest a completion for the current CWORD
    b ++= "  prev=\"${COMP_WORDS[COMP_CWORD-1]}\"\n"
    b ++= "  cur=\"${COMP_WORDS[COMP_CWORD]}\"\n"

    // handle arguments to named params
    if (!namedNonFlags.isEmpty) {
      b ++= "  case \"$prev\" in\n"
      for (param <- namedNonFlags) {
        b ++= "    "
        b ++= param.names.mkString("|")
        b ++= ")\n"

        for (line <- param.completer.split("\n")) {
          b ++= "      "
          b ++= line
          b ++= "\n"
        }
        b ++= "      return 0 ;;\n"
      }
      b ++= "  esac\n"
    }

    // handle named param completion
    if (!named.isEmpty) {
      b ++= "  case \"$cur\" in\n"
      b ++= "    -*)\n"
      b ++= "      COMPREPLY=( $(compgen -W '"
      b ++= named.flatMap(_.names).mkString(" ")
      b ++= "' -- \"$cur\") )\n"
      b ++= "      return 0 ;;\n"
      b ++= "  esac\n"
    }

    for ((param, idx) <- positionals.zipWithIndex) {
      b ++= s"  if [[ $$pos == $idx ]]; then\n"
      b ++= s"    # ${param.names.mkString(" ")}\n"
      for (line <- param.completer.split("\n")) {
        b ++= "    "
        b ++= line
        b ++= "\n"
      }
      b ++= "    return 0\n"
      b ++= "  fi\n"
    }
    b ++= "}\n"

    b ++= s"complete -F _${name.replace(" ", "_")} ${name.replace(" ", "-")}"
    // format: on
    b.result()
  }

}
