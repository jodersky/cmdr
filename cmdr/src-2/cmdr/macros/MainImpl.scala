package cmdr.macros

import scala.reflect.macros.blackbox.Context
import scala.collection.mutable

object MainImpl {

  def impl(c: Context)(annottees: c.Expr[Any]*): c.Tree = {
    import c.universe._
    val inputs: List[Tree] = annottees.map(_.tree).toList

    val placeholder = Literal(Constant(""))

    val (cmdName, cmdDescription, cmdVersion) = c.prefix.tree match {
      case q"new $_($name, $description, $version)" =>
        (Some(name), description, version)
      case q"new $_($name, $description)" =>
        (Some(name), description, placeholder)
      case q"new $_($name)" => (Some(name), placeholder, placeholder)
      case q"new $_()"      => (None, placeholder, placeholder)
    }

    val (annottee, expandees) = inputs match {
      case (param: ValDef) :: (rest @ (_ :: _))  => (param, rest)
      case (param: TypeDef) :: (rest @ (_ :: _)) => (param, rest)
      case _                                     => (EmptyTree, inputs)
    }
    val method: DefDef = expandees.head match {
      case d: DefDef => d
      case _ =>
        c.abort(c.enclosingPosition, "@main may only be applied to defs")
    }
    val methodParams = method.vparamss.flatten

    val cmdParamDecls = mutable.ListBuffer.empty[Tree]
    val cmdRepeatingDecls = mutable.ListBuffer.empty[Tree] // must come after non-repeating params

    /*
    NOTE: support for case classes is currenty disabled, as a macro annotation cannot
    access a default parameter value for some reason.
    E.g. consider

      case class Foo(x: Int = 1)

    the compiler encodes the default parameter in the following way:

      object Foo {
        def apply$default$1 = 1
      }

    User code can freely reference `Foo.apply$default$1` (although not recommended),
    however somehow code generated by the macro annotation cannot:

    [error] Main.scala:19:4: not found: value Foo.apply$default$1
    [error] Error occurred in an application involving default arguments.

    Until this is resolved, only direct parameters are supported by this macro.

    def traverse(path: String = "", method: MethodSymbol): Tree = {
      val pNames: List[TermName] = method.paramLists.flatten.zipWithIndex.map {
        case (param, idx) =>
          val tpe = param.typeSignature.typeSymbol
          val pName = TermName(c.freshName("p"))
          // case classes are handled recursively
          if (tpe.isClass && tpe.asClass.isCaseClass) {
            val tree = traverse(
              path + param.name + ".",
              tpe.companion.info.decl(TermName("apply")).asMethod
            )
            cmdParamDecls += q"val $pName = $tree"
            pName
          } else {
            val defaultName = TermName(s"${method.name}$$default$$${idx + 1}")
            val default = method.owner.info.decl(defaultName)

            val cmdParamName = s"--$path${util.snakify(param.name.toString)}"

            if (default == NoSymbol) {
              cmdParamDecls += q"""val $pName = parser.requiredParam[${param.typeSignature}]($cmdParamName)"""
            } else {
              cmdParamDecls += q"""val $pName = parser.param[${param.typeSignature}]($cmdParamName, ${TermName(default.fullName)})"""
            }
            pName
          }
      }
      q"${TermName(method.fullName)}(..$pNames)"
    }
     */

    val cmdParamIdents = methodParams.map {
      case v @ ValDef(mods, name, tpet, default) =>
        var help: Tree = Literal(Constant(""))
        var aliases = List[Tree]()
        mods.annotations.foreach { annot0 =>
          val annot1 = c.typecheck(annot0)
          if (annot1.tpe =:= typeOf[cmdr.help]) {
            val q"new $_($arg)" = annot1
            help = arg
          } else if (annot1.tpe =:= typeOf[cmdr.alias]) {
            val q"new $_($arg)" = annot1
            aliases = arg :: aliases
          }
        }

        val tpe = c.typecheck(tpet, mode = c.TYPEmode).tpe
        val ident = TermName(c.freshName("p"))
        val cmdParamName = util.kebabify(name.toString)

        // Note: special support for case classes is currently not supported (see comment above)
        //
        // val isCaseClass =
        //   tpe.typeSymbol.isClass && tpe.typeSymbol.asClass.isCaseClass
        // if (isCaseClass) {
        //   val r = traverse(name + ".", tpe.companion.decl(TermName("apply")).asMethod)
        //   cmdParamDecls += q"val $ident = $r"
        //   ident
        // }

        if (!default.isEmpty) {
          val dashName = s"--$cmdParamName"
          val envBase: String = util.snakify(name.toString).toUpperCase
          val envName: Tree = cmdName match {
            case None       => q"$envBase"
            case Some(prog) => q"""${prog}.toUpperCase + "_" + $envBase"""
          }
          val isFlag = tpe =:= typeOf[Boolean]
          cmdParamDecls += q"""val $ident = parser.param[$tpe]($dashName, $default, $envName, help=$help, aliases = List(..$aliases), flag=$isFlag)"""
        } else if (tpe <:< typeOf[Seq[_]]) {
          val t = tpe.typeArgs.head
          cmdRepeatingDecls += q"""val $ident = parser.repeatedParam[$t]($cmdParamName, help=$help)"""
        } else {
          cmdParamDecls += q"""val $ident = parser.requiredParam[$tpe]($cmdParamName, help=$help)"""
        }
        ident
    }
    val cmdParamValues = cmdParamIdents.map(p => q"$p()")

    val res = q"""
    ${expandees.head}
    def main(args: Array[String]): Unit = {
      val parser = _root_.cmdr.ArgumentParser($cmdName.getOrElse(""), $cmdDescription, $cmdVersion)
      ..$cmdParamDecls
      ..$cmdRepeatingDecls
      parser.parse(args)
      ${method.name}(..$cmdParamValues)
    }
    """
    // c.info(c.enclosingPosition, res.toString, true)
    res
  }

}
